{"version":3,"file":"unwrapFunction.js","sourceRoot":"","sources":["../../src/internal/unwrapFunction.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,OAAO,EAAE,MAAM,wBAAwB,CAAC;AACjD,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AAC/C,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,aAAa,CAAC;AAEpD,IAAI,MAA6B,CAAC;AAElC,SAAS,qBAAqB,CAAI,QAAkB,EAAE,OAAU;IAC5D,cAAc,CAAC,GAAG,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,oBAAoB,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;AACvF,CAAC;AAED;;;;;;;;;GASG;AACH,wBAAwB;AACxB,MAAM,UAAU,mBAAmB,CAAO,QAAiB;IACvD,MAAM,GAAG,MAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC;IACnC,OAAO,UAAS,OAAY;QACxB,OAAQ,OAAO,CAAC,QAAQ,CAAc,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;IACtF,CAAC,CAAC;AACN,CAAC;AAED;;;;;;;GAOG;AACH,wBAAwB;AACxB,MAAM,UAAU,eAAe,CAAO,QAAiB,EAAE,QAAY;IACjE,MAAM,GAAG,MAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC;IACnC,IAAI,KAAK,GAAG,QAAQ,IAAI,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAE3C,OAAO,UAAS,OAAY;QACxB,IAAI,OAAO,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,KAAK,CAAC;QACtD,IAAI,OAAO,EAAE;YACT,OAAQ,OAAoB,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;SAC3E;QAED,qBAAqB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC7C,CAAC,CAAC;AACN,CAAC;AAED;;;;;;;;GAQG;AACH,wBAAwB;AACxB,MAAM,UAAU,uBAAuB,CAAqC,QAAiB,EAAE,QAAW,EAAE,QAAW;IACnH,MAAM,GAAG,MAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC;IACnC,IAAI,KAAK,GAAG,QAAQ,IAAI,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAE3C,OAAO,UAAS,OAAY;QACxB,IAAI,OAAO,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,KAAK,CAAC;QACtD,IAAI,OAAO,IAAI,QAAQ,EAAE;YACrB,IAAI,OAAO,GAAG,SAAS,CAAC;YACxB,OAAQ,CAAC,OAAO,IAAI,QAAQ,CAAc,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;SAC3G;QAED,qBAAqB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC7C,CAAC,CAAC;AACN,CAAC;AAED;;;;;;;;;GASG;AACH,wBAAwB;AACxB,MAAM,UAAU,WAAW,CAAI,QAAiB;IAC5C,OAAO,UAAU,OAAU;QACvB,OAAO,OAAO,CAAC,QAAQ,CAAC,CAAC;IAC7B,CAAC,CAAC;AACN,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { dumpObj } from \"../helpers/diagnostics\";\r\nimport { throwTypeError } from \"../helpers/throw\";\r\nimport { asString } from \"../string/as_string\";\r\nimport { ArrProto, CALL, SLICE } from \"./constants\";\r\n\r\nlet _slice: typeof ArrProto.slice;\r\n\r\nfunction _throwMissingFunction<T>(funcName:  keyof T, thisArg: T): never {\r\n    throwTypeError(\"'\" + asString(funcName) + \"' not defined for \" + dumpObj(thisArg));\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to run the named function on the passed first argument, this does not support polyfill\r\n * or prototype fallback, so the function must exist on the provided first argument.\r\n * If the first argument is null, undefined or the function does not exist an exception will be thrown\r\n * by the runtime\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _unwrapInstFunction<R, T>(funcName: keyof T) {\r\n    _slice = _slice || ArrProto[SLICE];\r\n    return function(thisArg: any): R {\r\n        return (thisArg[funcName] as Function).apply(thisArg, _slice[CALL](arguments, 1));\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to convert an expanded function back into an instance `this` function call\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @param clsProto - The Class or class prototype to fallback to if the instance doesn't have the function.\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _unwrapFunction<R, T>(funcName: keyof T, clsProto?: T) {\r\n    _slice = _slice || ArrProto[SLICE];\r\n    let clsFn = clsProto && clsProto[funcName];\r\n\r\n    return function(thisArg: any): R {\r\n        let theFunc = (thisArg && thisArg[funcName]) || clsFn;\r\n        if (theFunc) {\r\n            return (theFunc as Function).apply(thisArg, _slice[CALL](arguments, 1));\r\n        }\r\n\r\n        _throwMissingFunction(funcName, thisArg);\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to convert an expanded function back into an instance `this` function call\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @param clsProto - The Class or class prototype to fallback to if the instance doesn't have the function.\r\n * @param polyFunc - The function to call if not available on the thisArg, act like the polyfill\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _unwrapFunctionWithPoly<T, P extends (...args: any) => any>(funcName: keyof T, clsProto: T, polyFunc: P) {\r\n    _slice = _slice || ArrProto[SLICE];\r\n    let clsFn = clsProto && clsProto[funcName];\r\n\r\n    return function(thisArg: any): ReturnType<P> {\r\n        let theFunc = (thisArg && thisArg[funcName]) || clsFn;\r\n        if (theFunc || polyFunc) {\r\n            let theArgs = arguments;\r\n            return ((theFunc || polyFunc) as Function).apply(thisArg, theFunc ? _slice[CALL](theArgs, 1) : theArgs);\r\n        }\r\n\r\n        _throwMissingFunction(funcName, thisArg);\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to lookup and return the named property from the first argument (which becomes the this)\r\n *\r\n * @since 0.4.2\r\n * @typeParam T - The type of the object which contains the propName\r\n * @param propName - The property name\r\n * @returns The value of the property\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _unwrapProp<T>(propName: keyof T) {\r\n    return function (thisArg: T) {\r\n        return thisArg[propName];\r\n    };\r\n}"]}